# SICP 观后感

> 编程是这样一种活动，是我们对问题思考过程的形式化描述。
> 对形式化问题的求解就是计算，代替我们进行这个过程的就是计算机。
>
> 什么是形式化描述？形式化描述是指按照一定的规则对事物进行描述。
> 对程序员而言, 这个规则就是所使用编程编程语言的语法规则。
>
> ———— 沃兹基 硕德

## 以下没有剧透

### 前言

最近花了点时间快速的把 SICP 的刷了一遍，刷的是 1984 的视频版本。
刷完后发现, 这门课程无愧于那么多人给予的那么高的评价。

如果这个世界上只能有一门计算机课程, 我希望是 SICP 。

如果这个世界上只能有一门编程语言, 我希望是 lisp 。

由于刷得不是很仔细, 所以有些地方有些疏漏, 还请见谅。

### 为什么 SICP 是神

SICP 的全名是 "Structure and Interpretation of Computer Programs",
翻译过来就是《计算机程序的构造和解释》。
所谓构造, 就是指如何编写程序,
所谓解释, 就是编写出来的程序是什么意思。
对程序的解释可以引申为程序的每一部分所对应的计算步骤,
也就是程序如何运行。

这门课程把计算机专业本科所涉及到专业课程
( 计算机组成原理, 编译原理, 程序设计, 数据结构 )
都相对简单而深入的讲解了一遍,
它真的能带领你重新设计一台自己的计算机。
SICP 向我们深刻的展示了什么是计算, 什么是计算机科学,

这门课不断的带领学生突破原本视角的桎梏,
进入一种新的领域来审视自己原本的关于计算和计算机的思考。
这种连续的脑力风暴带来的尤里卡时刻 ( 类似于 `啊, 原来是这样` 的时刻 )
给人带来的精神上的享受想必也是这么多人给予这么高评价的原因。

现在的计算机本科课程都是给予图灵机 ( 或冯诺依曼机 ) 抽象的课程,
c 教授到指针就涉及到对内存模型的理解,
而 c 是如何在内存上工作的这个知识点就分散在好几门不同的课程中。
即前面课程的知识和后面课程的知识是强依赖的,
如果对内存模型理解有误, 就几乎无法理解指针。

而 SICP 不一样, lisp 是一门基于 lambda 演算而被设计的语言,
lisp 里只有函数调用, 而 lambda 是更接近接受了 12 年数学的人的心智模型,
SICP 通过在不同的课堂目标上扩展 lisp 的语义,
能够在不引入外部依赖的情况下, 自洽的解释完了本门课程。
上完这门课, 你是真的能在异世界用魔法造计算机。

在上这门课时, 我时常能感受到两位教授对于传授这门课的热情,
甚至会在讲述到整门课的高潮时甚至还会穿成魔法师的样子。

教授这门课的两位教授经常用魔法来喻指黑盒模型。
在我们不明白其中的工作原理的时候,
两位教授会告诉我们这是魔法, 但最后都会揭开魔法的原理,
告诉我们魔法不存在。

但这门课有没有真正的魔法呢? 我认为这个魔法就是 lisp 本身,
lisp 本身的语法非常简单, 就是一个嵌套的 s 表达式。
但这并不意味着 lisp 是一门不完善的语言,
课程中会用这门语言去不停的实现其它的编程语言,
甚至能够用不到两三百行的 lisp 代码解析其自身,
这一切都表明 lisp 是一门精心设计的语言, lisp 就是魔法本身。

如果你的时间很少, 甚至这可能是你唯一接触计算机的时间,
那么为什么不试试看看 SICP 呢? SICP 广泛的教学内容几乎涉及到了计算机的每一方面,
你很难在其它课程里获得这么广阔的视野了。

如果你的时间很多, 为什么不试试看看 SICP 呢?
SICP 的课程能带你更深入的了解什么是计算, 什么是计算机?
而且整门课也就20来个课时, 你与其花时间在那些随时会淘汰的技术上,
不如跟随两位教授, 在计算机的世界畅游一番。

### 其它看法

这门课难不难? 难!
这门课把几乎本科涉及到的所有课程都讲解了一遍,
就内容广度而言, 更适合作为导论课,
但就内容精深程度而言, 更适合作为一门专业课。
视频拍摄于 1984 年, 当时受限于视频制作水平和技术,
相较于现在的视频作品信息密度要底一个挡位
( 不信的话可以去看一下 B 站上哪些嘴巴烫的 up 主 ) 。
课程全程的语速都比较中正平和 ( 相对于现在的视频而言 ) ,
这种信息密度低于课程教学需求带来了极高的学习难度,
如果视频的信息密度能再提升一些, 想必能有更多的人更好的接受这门课程。

没错, 我的意思是这门课程需要现代化改造, 即用现已有的技术充实原本课程的内容,
对相对难以理解的概念进行详细的讲解, 更改一些具有时代鸿沟的例子
( 比如那个用酶工作机制比喻模式匹配的例子 )
, 以期降低课程的学习门槛。

有人会问: " SICP 不是有 python 和 js 版的吗?"

对此, 我给出我关于其它语言版本 SICP 的看法,
诚然 python 和 js 都是非常优秀的编程语言 ( 狗头保命 ) ,
但 lisp 是 SICP 的魅力之一,
抛弃这门语言而选择用其它方式教授这门课程会使其失色不少,
而且使用其它语言会破坏这门课程的完整性。
虽然课程的名字叫计算机程序的构造和解释,
但其实主要讲的还是如何用 lambda 演算来构造计算机。

还有人会问: "SICP 不是有 2004 年的 lisp 版吗?"

对此, 我也给出我关于这个版本的看法,
诚然, 这也是一门非常优秀的课程 ( 狗头保命 ) ,
相较于之前课程由于教学手段的限制,
这门课程将一些难以理解的概念进行了详细的讲解,
但可能是因为课时原因, 这个版本的课程相对于另一个版本在初期讲得很详细,
但后面删减了一些内容, 比如我就没有看到 prolog 相关的逻辑式编程的内容。

当然, 我是没有为 SICP 作注这个水准的, 这只是我自己的一个妄想而已。
我只是希望像这样优秀的课程能得到更广泛的学习,
其中优秀的思想能得到更广泛的传播。

### 观看建议

学完这门课程你可能对马上要开展的工作没有帮助,
比如你看完这门课程不太可能帮助写网页和写服务器。
但能真正开阔你关于计算机的视野, 让你知道,
哦, 原来计算机真的可以办到这样的事,
哦, 原来计算机是这样做的。

如果你要开始学习这门课程, 请不要把精力集中在两位教授所提出的例子上来,
而尽可能的集中到例子本身的结构和例子背后一些深刻的思想上来。

## 以下涉及剧透

以下是我对课程内容进行的一个简要总结。

涉及剧透, 建议不要看。

---

每一节课都分为 a ( 上半节课 ) 部分和 b ( 下半截课 ) 部分。

### 第一节课

第一节课开宗明义的介绍了什么是计算面积科学,
计算机科学研究什么, 计算机科学研究对计算过程的形式化描述。
随后简要介绍了一下 lisp , 并用求平方根的算法引出了黑盒模型和不动点。

后半节课继续介绍了一下 lisp 里一些常用的函数, 然后介绍了函数的代换模型,
如何运用代换模型得到程序的运行结果,
然后基于代换模型简单粗暴的向学生展示了什么是时间复杂度和空间复杂度。
然后以汉诺塔为例介绍了递归, 递归是 lisp 常用的流程控制手段。

### 第二节课

第二节课就展示了 lisp 的强大, 在 lisp 里,
函数 ( procedure, 和函数的概念有些区别, 但此处可以简单理解成函数 )
与数据并无区别, 你可以往函数里传函数, 这样的函数被称为高阶过程
( Higher-order Procedure ) 。
虽然现在 lambda 表达式已经是现代语言的标配了,
但要想到这门课是 1984 年的课, 那时的语言 lambda 表达式还不算标配吧?

教授基于数学中的求和符号定义了一个可以自定计算模式的求和函数。
然后基于这种求和模式, 组合出了一些列常用的数学公式, 比如求平均值等。

然后又写了一遍求函数不动点的函数, 记住这个不动点, 后面还会出现。

2-b 终于进入正题了, 讲计算机程序如何构造,
实现了一个简单的分数的运算系统, 这涉及到数据的复合,
于是又介绍了 cons 。

然后神奇的来了, 你肯定以为 cons 又是什么在 lisp 解释器上开的洞之类的魔法对不对?
其实不是哒！cons 返回的是一个 procedure ,
其实就算 lisp 不提供 cons 函数你也能自己造一个出来。

### 第三节课

上半节课的上半截讲了一个在 lisp 里比较基础的数据结构, 叫 list 。
list 是基于 cons 组合而成的, list 经由 cons 用类似链表的方式组合而成。

然后基于 list 又定义了 map 和 accumulate ( 类似今天的 reduce ) 函数。

上半节课的后半截又举了一个画图的例子来展示如何用 lisp 解决问题。
用 lisp 解决问题的方法就是不用 lisp 来解决问题, 而是用 lisp 实现一门语言,
再用这门语言来解决问题, 这被称为元语言抽象。
后面遇到的大型问题基本都是这样解决的。

从 3-b 开始就进入高能了, 这节课直接教你实现一个函数求导的程序,
不是数值求导, 而是符号求导, 是把 `x => x * x` 求导成 `x => 2 * x ` 这样的函数,
而且能对结果进行代数化简。

但这节课提出了一个关于引用的概念,
讲授的有点语焉不详, 如果实在无法理解什么是引用,
可以把它理解成是一种阻止 lisp 的表达式立即求值并生成对应顺序 list 的一种手段。

这节课还提了一个关于引用透明性的概念:

> We can't substitute into what's called referentially opaque contexts,
> of which a quotation is the prototypical type of referentially opaque context.
>
> 在一个引用不透明的上下文中, 我们无法进行代换,
> “引用”就是引用不透明的典型。

这里的引用透明性应该和透明传输进行类比理解。

假设在一根无干扰的数字信号线上, 我们想要将传输的内容划分成一段一段的(帧)。
我们就需要有符号来在无限长的报文中区分分开的这些段落(报文)。
假设我们用 `42` 来标志报文的结尾, 但这样我们就无法在上面传输带有 `42` 的报文。
这就是不透明传输, 即如果我的报文里带有某个符号可能会引起系统无法正常工作。

同样, 在引用不透明的上下文中(在此处就是 lisp 的引用),
我们在某处使用了某个符号, 可能会导致整个系统无法正常工作。

一个简单的例子是 C 的宏, 如果你定义的宏的名称不小心覆盖了系统定义的宏的名称,
就会引发未知的错误,
所以这些系统文件的提供者都把自己的名字取得很奇怪来避免普通用户命中自己定义的宏。


### 第四节课

4-a 承接上文, 基于符号求导的需求提出了模式匹配的概念。
记住这个模式匹配, 后面还会出现。
这下这个符号求导程序是真的能够实现一些四则运算和整数幂运算的求导了。

上半节课相当于造了一门基于 lisp 的求函数导数的语言。

4-b 则是直接造了个代数的四则运算系统,
教授从最简单的分数讲起, 一直不停的扩展运算支持的数域,
从有理数到复数再到初等代数再到矩阵。

几乎是在 lisp 上实现了一个类型系统,
在这个简单的类型系统上为了保持加法函数语义的一致做了多态。
但这个计算系统也很弱, 甚至不支持实数和复数相加, 因为没有定义不同类型的行为。

这节课算是直观的展现了 lisp 的强大, 基于 lisp 你可以构造任何你想要构造的语言。

### 第五节课

5-a 介绍了 lisp 的副作用语义, 之前讲的 lisp 是没有赋值语句的。
因为有了赋值语句, 也就有了私有变量, 有了私有变量, 也就有了对象,
所以 lisp 也可以做 OOP 。

但赋值语句破坏了纯函数的性质, 这破坏了代换模型, 也破坏了一些好的性质。
那么是什么样的好处使得我们要做这样的事呢?

比如之前的 lisp 不能实现 random 函数,
普通的 random 函数都是对一个初始值不停的做 Hash
( 因为我们认为 hash 是不可预测的, 所以是随机的 ) ,
这就要求 random 函数要持有私有状态 ( 后面这个问题可以通过流来解决 ) 。

5-b 则是带领我们用 lisp 做了个数字电路的模拟系统,
这种带有状态更新的问题天然就更适合 OOP 来做。

这也是我十分推荐这门课的原因所在, 在学完 lisp 的基础之后,
这几节课的跨度可以说十分之大。

### 第六节课

这节课讲了一个十分强大的编程模型 __流模型__ 。

流模型是一种将应用编写顺序和执行顺序解耦的强大的编程模型,
这种模型使得其能够描述无穷的数据。
当然我们只能从流中取出有限个数据, 但这个数据结构允许我们将其当成拥有无限的数据。

这个模型在大数据领域有较为广泛的应用, 就是现在是个人都知道的 map-reduce 架构,
当然, map-reduce 架构并不完全是流模型,
只是流模型将执行顺序解耦的强大能力使其成为了大数据中常用的编程模型。

我们可以把 random 看成一个无限长的流, 这样就不需要副作用语句了。
当然, 上一节课的数字电路的例子也可以用流模型来表示, 这样也就不需要副作用了。

流模型强大的能力来源于惰性求值,
只是通过一些编程的技巧使其看上去好像可以取出无限的数据罢了。

但流模型强就强在执行顺序的解耦, 弱也弱在执行顺序的解耦。
它的长处使其在大数据领域有广泛的应用,
代价则是失去时序控制能力, 在没有时间标签的情况下,
你永远不知道哪个标签先到, 哪个标签后到。

这节课还基于惰性求值的流写了一个数值求解微分方程的程序,
但仔细想了想, 这种编写方法不具有推广性, 即不能推广到一般的一次微分方程上。

这节课还实现了一个素数流, 和廖雪峰的 python 生成器版贼像。

### 第七节课

这节课对于不少人来说应该是个高潮,
教大家用 lisp 实现一个 lisp 解释器, 课程里叫元循环求值器。
但对我这种接受过计算机本科教育的人而言就没有那么震撼了。

有一种被剧透了的难受感。

这节课真正震撼我的地方还在于它用很少的代码就写了一个解释器,
我自己按照它的思路写了一下, 在只考虑 lambda 演算的情况下也就两三百行吧?
我自己写的编译原理的作业解释器的某个模块都不止这么多。

教授这一节课程的教授想必是对这一节课程非常有信心,
以至于穿上了魔法师的服饰。

在讲完解释器的基本结构后, 讲了如何只通过 lambda 实现递归
( 因为这个解释器只支持 lambda 运算 ) 。

即每一个递归函数都可以通过某种方式写成对应的传入自身引用的函数,
而前者是后者的不动点, 通过把求解不动点的函数应用到这个非递归的函数上,
就得到了对应的递归版本。
而这个求解不动点的函数恰好可以用 lambda 表示出来,
它就是大名鼎鼎的不动点组合子 ( 通常表示成 Y ) :

```lisp
(lambda (f) ((lambda (x) (f (x x))) (lambda (x) (f (x x)))))
```

但不要把这行代码直接在 lisp 里运行, 因为 lisp 参数不是惰性求值的,
对于 `Y F = F ( Y F )` , lisp 会把括号里的东西算出来,
不把括号里的东西算出来是不会把值传进去的,
所以 lisp 会一直不停的递归不停的递归, 直到卡死。

为了实现一个能在 lisp 跑的不动点组合子 Y ,
你需要用一点在流里学到的延迟求值的技巧, 需要实现一个满足:

```
Y F = F (lambda (n) ((Y F) n))
```

的不动点组合子, 根据前一个不动点组合子,
我们很容易就得到满足上述性质的这个不动点组合子 Y :

```lisp
(lambda (f)
  ((lambda (x) (f (x x)))
    (lambda (x) (f (lambda (n) ((x x) n))))))
```

你们可以用这个试一试。

跑题了, 书接前文, 这可以说是前面课程的一个大高潮了,
我看到这里就已经定死了它在我心中神作的地位,
教授显然也对这节课很满意, 搞了一次形式化的颁奖典礼,
祝贺我们成为
`the grand  recursive order of the lambda caculus hackers`
( 神圣的递归秩序中的一名 lambda 演算黑客 )。

在写这个文章时, 我又看到了这个片段

> 让我们思考一下 eval-apply 求值器循环, 
> 我在这里写了一大堆递归方程,
> 这些方程就像上一个方程联立起来一样
> ...
> 则 lisp 则是某个过程的不动点

我终于理解这句话了, lisp 的解释器虽然也是用双递归的方式写的,
但也能用代换模型得到单递归的形式,
单递归的形式也就可以用前面提到的不动点组合子的形式写出来,
所以整个 lisp 的 eval-apply 元循环求值器就是某个 lambda 的不动点。

之前我觉得那枚徽章没什么意义, 现在我懂了, 那枚徽章很有意义。

### 第八节课

经过了上节课的洗礼后, 你可能已经认为这门课已经没多少货了。

错! 错得离谱, 这一节讲的是逻辑式编程, 用逻辑式编写的程序可以反向求值。

即我定义了一个函数 ( 通常被叫做规则 ) ,
我可以通过函数的运行结果得到函数可能的输入输出。
简直强暴了。

这节课用流和模式匹配的方式实现了一个类似于 prolog 的规则引擎。

像这样的逻辑式编程有一些问题, 或者说这个编程模型有一些问题。

对于这个规则引擎无法推理出来的规则是应该为真还是为假呢?

教授提出了一个判断的标准, 叫 `封闭世界假说` ,
意思是无法判断的命题都默认为假。 
个人认为应该是不真不假, 即除了真假之外应该有其它值描述命题的专题。
后来搜了一下, 这就是所谓的三值逻辑, 三值逻辑是双值逻辑的推广,
多值逻辑是三值逻辑的推广 ( 三值逻辑我还大致能理解, 多值逻辑完全理解不了 ) 。
三值逻辑似乎已经运用于 sql 查询了?

### 第九节课

这节课的前半部分对我而言也是平平无奇,
毕竟对于一个接受过计算机本科教育的人而言,
把一份简单的代码翻译成 Verilog ,
再把 Verilog 翻译成数字电路实在是不是什么很难事。

有一种被剧透了的难受感。

但我感兴趣的是前半部分的对于机器的抽象,
然后是如何对递归的函数进行翻译, 递归的函数意味着要有类似生命周期的概念。
要在一个声明周期的对应时段保存机器状态,
很自然的就引出了栈的概念, 真的, 比起现在一堆讲不清楚函数调用栈的博客,
这个是讲得最清楚的。

然后真正让我吃惊的地方来了, 既然我们已经能把递归的 lisp 代码翻译成硬件电路了,
那么我们能不能把 eval-apply 的 lisp 求值器直接翻译成硬件电路呢?
好家伙, 其它人也就把程序翻译成汇编代码, 这里把代码翻译成硬件电路,
原来这就是 SICP 的 Interpretation ( 解释 ) 啊。

我宣布 SICP 在我的心中再次超神。

### 第十节课

最后一节讲得是如何把 lisp 翻译成汇编代码,
感觉是一些比较琐碎和具体的内容。
看得不太仔细, 没有什么感想。

但当那位提问的学生问: "这是最后一个问题了吗?"

一股无名的悲伤填充在我的心中。

感谢两位教授的精彩讲解, 在这个无聊的新年前后用 lisp 的魔法给予了我快乐。
