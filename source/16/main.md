# 递归函数的复合到CPS

普通函数的复合我们很常见,
比如我们有一个 `parseInt :: String -> Int` 的函数,
它把一个字符串解析成整数,
以及一个 `add114514 :: Int -> Int` ,
它把任何数都加上一个很臭的数字.

我们复合这两个函数 `add114514 . parseInt :: String -> Int` ,
得到了一个先把字符串解析成整数后再加上一个很臭数字的函数.

一切都非常简单, 对吧？

那么复合两个递归函数呢?


## 从零开始

假设我有两个转换树结构的函数 `f1 :: t1 -> t2` 和 `f2 :: t2 -> t3` .

如果我要将其复合的话非常简单 `.\ t -> f2 (f1 x)` ( 此处的 `.\` 是 lambda 符号 ) .

但这不符合我的要求, 我们知道转换树结构的函数会有一个遍历树的过程,
会首先递归的向下遍历树的节点并进行, 然后再向上遍历建立树的结构.

两个函数复合就会多两次遍历, 三个函数复合就会多四次遍历.
有没有什么办法能够消除掉中间的遍历过程呢?

~~省流不看: 没有, 最后失败了~~

## Y组合子给我的启示

在最简单的 lambda-演算 中, 我们通过 Y组合子 来创建一个递归函数.

最常见的递归函数比如 `fib` 函数, 用普通的递归可以写作:

```
let fib (x) = {
  if x == 0 then
    1
  elif x == 1 then
    1
  else
    fib (x - 1) + fib (x - 2)
}
```

而 lambda-演算 中由于函数没有名字, 是无法像上例一样那么书写递归函数的.
但后来人们发现了一个叫 Y组合子 的东西, 你可以简单的把它看作是一个函数, 满足:

```
Fix f = f (Fix f) = f (f (Fix f)) = ... = f (f (f (f ...)))
```

具体的工作原理这里暂且不细讲, 总之,
它可以把一个非递归的函数变成一个递归的函数.

我们通过 Y组合子 , 可以这样写出一个 `fib` 递归函数:

```
let fib = Fix (.\ f n -> {
  if x === 0 then
    1
  elif x == 1 then
    1
  else
    f (x - 1) + f (x - 2)
})
```

这个包裹在 `Fix` 中的 lambda函数 中的 `f` 实际上就是这个递归函数本身,
那么我们不禁要思考, 如果我们把这里的 `f` 替换成要复合的函数,
是不是就能满足我们的要求了?

## 行得通吗?

但是行不通, 我们不妨像文章开头一样,
先考虑两个函数 `f1 :: t1 -> t2` 和 `f2:: t2 -> t3` . 

我们要将其转换成 Y组合子 的形式,
`f1 = Fix tf1` , `f2 = Fix tf2` .

这样的话 `tf1` 的类型就应该是 `(t1 -> t2) -> t1 -> t2`,
而 `tf2` 的类型就是 `(t2 -> t3) -> t2 -> t3` .

而这样两个类型的函数签名是怎么看也不可能复合得起来的.
