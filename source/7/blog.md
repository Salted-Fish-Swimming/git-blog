# JavaScript 构建工具的演进

一个初入 JavaScript 的萌新在面对各种黑盒一样的开发环境时,
最难以理解的就是各种构建工具了, 而网上流传的各种资料多是各个构建工具的使用说明.
在萌新们对这些构建工具的提供的总体的抽象的功能缺乏了解时,
太过详细的讲解各种工具的各个使用细节,
对萌新了解并使用各种打包工具工具而言并不友好.

所以本文简单分析一下各个构建工具的设计思路,
简单了解一下构建工具背后的设计思想和构建工具的演变.

在早期的前端开发过程中, 伴随着前端项目越来越复杂,
早期的把 JS 代码写进单个 HTML 文件或者写进单个文件的方式,
资源文件直接拖上服务器部署的方式, 已经无法满足前端开发的需求.

比如网页的图片数量过多, http1 无法充分利用单个 TCP 链接资源,
导致服务器压力过大, 就需要以 "雪碧图" 的方式打包大多数图片.

同样的, 我们也可以按照类似的方式打包 CSS 文件和 JS 文件.

我们还希望我梦能用高版本的语法书写的 JS 文件 ( 比如 ES6 的 class, => , ?. 等语法糖 )
能够在低版本浏览器中运行, 或者我使用了 React , 要转换 JSX 等语法,
我们则需要通过 Babel 等工具进行转换.

我们还会使用 Less / Sass 等 CSS 预处理语言来编写样式等等.

我们看到, 这时, 我们的工程非常复杂, 内部需要处理的不同的工程资源很多,
当我们编写完代码后, 不仅要处理 JS 和 CSS 这样的代码文件,
还需要处理图片这样的资源文件.

这个处理过程每次都大差不差, 而且敲的重复命令很多.
既然如此, 我们可不可以编写一段代码, 使得它可以代替我们完成这个项目的构建过程?

## 第一代构建工具 - grunt / gulp

当然可以 ! 用什么呢 ? bash ? 估计除了运维, 没有人能容忍那样反人类的语法.
前端最好的工具当然就是 JS 本身啦 !  grunt / gulp 就是当时前端社区的解决方案,
也就是本文所说的第一代的构建工具.

这些第一代构建工具的特点是:
构建过程的依赖需要由开发人员显式的指定.  也就是 `显式的依赖指定` .

即项目里的文件和资源之间的关系需要在对应的配置文件中显式的指定.

### grunt

grunt 是一个基于任务的构建工具, 任务是其基本组成单位.
当在命令行执行 `npx grunt` 时,
会先讲当前路径下的 `grungfile.js` 文件当作一个模块导入,
它期望你导出的是一个接受一个 `grunt` 对象的一个函数.
它会讲一个 `grunt` 对象以函数调用的方式, 注入到你导出的函数中,
然后, 你就可以用这个 `grunt` 对象声明你的任务了.

```JavaScript
// 导出一个接受 grunt 的函数
module.exports = (grunt) => {
  /* */ 
  grunt.registerTask('taskname', () => {
    /* your task code */;
  });
  grunt.registerTask('taskname', [ /* ...other rigistter task */ ])
  /*  */
}
```

```JavaScript
moudle.exports = (grunt) => {
  grunt.registerTask('taskname', function () {
    const done = this.async();
    /*  */
    done();
  });
}
```

### gulp

gulp 则是在 grunt 的基础上, 为文件处理特化出了一个 Vinyl 的文件流式 api,
采用高阶函数去配置插件, 任务直接声明在 `module.exports` 的导出模块之中.

简而言之, gulp 更 JS 化, 'gulpfile.js' 写起来更像是个 JS 文件,
而 grunt 更像是个 dsl .

```JavaScript

```

## 第二代构建工具

上述的那些构建工具本身可以看作是 'makefile' , 'package.json'
等设计思想在早期前端构建工具中的投射.
